<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>LaserAligner â€” MiniGame</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="LaserAligner">
<style>
:root{
  --bg:#0b0c0d;--panel:#1c1c1e;--card:rgba(255,255,255,.08);--b:#2c2c2e;
  --ok:#30d158;--warn:#ffd60a;--bad:#ff453a;--txt:#fff;--muted:#b7bbc0;--accent:#0a84ff
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;font:16px -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Ubuntu,'Helvetica Neue',Arial,sans-serif;background:var(--bg);color:var(--txt)}
.app{display:flex;flex-direction:column;height:100%}
.header{padding:14px 18px;display:flex;justify-content:space-between;align-items:center;
  backdrop-filter:saturate(180%) blur(20px);background:rgba(18,18,18,.85);position:sticky;top:0;z-index:10}
.title{font-weight:800}
.btn{appearance:none;border:0;border-radius:12px;padding:10px 14px;background:var(--accent);color:#fff;font-weight:700}
.btn.ghost{background:transparent;border:1px solid var(--b);color:#d0d3d7}
.grid-2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.grid-3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px}
.panel{background:var(--panel);border-top:1px solid var(--b);padding:10px}
.bar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.tag{padding:6px 10px;border-radius:999px;background:#1c1c1e;border:1px solid var(--b);color:#d0d3d7;font-weight:700;font-size:12px}
.card{background:var(--card);border:1px solid var(--b);border-radius:16px;padding:14px}
h2{margin:0 0 6px 0;font-size:18px}
.small{color:var(--muted);font-size:13px}
canvas{touch-action:none;background:#111214;border:1px solid var(--b);border-radius:16px}
.footer{padding:10px;text-align:center;color:var(--muted)}
#stars{font-size:20px;letter-spacing:2px}
.knob{display:flex;flex-direction:column;gap:6px;align-items:stretch}
.knob label{font-weight:700;font-size:13px;color:#d0d3d7}
input[type=range]{-webkit-appearance:none;width:100%;height:28px;background:transparent}
input[type=range]::-webkit-slider-runnable-track{height:4px;background:var(--b);border-radius:999px}
input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:24px;height:24px;border-radius:50%;margin-top:-10px;background:#fff;border:2px solid #000}
.progress{height:8px;border-radius:999px;background:#222}
.progress>div{height:100%;border-radius:inherit;background:linear-gradient(90deg,var(--ok),#34c759)}
.badge{display:inline-block;padding:4px 8px;border-radius:10px;border:1px solid var(--b);background:#1c1c1e;color:#d0d3d7;font-weight:700;font-size:12px}
.win{border-color:#2ea043;background:rgba(46,160,67,.15)}
.shake{animation:shake .3s}
@keyframes shake{0%,100%{transform:translateX(0)}20%{transform:translateX(-4px)}40%{transform:translateX(4px)}60%{transform:translateX(-4px)}80%{transform:translateX(4px)}}
.hidden{display:none}
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <div class="title">LaserAligner Â· MiniGame</div>
    <button class="btn" id="playBtn">Gioca</button>
  </div>

  <div class="panel bar">
    <span class="tag" id="levelTag">Livello 1 Â· M1â†’M2</span>
    <span class="tag" id="modeTag">ModalitÃ : Training</span>
    <span class="tag">Tolleranza <span id="tolVal">0.020</span></span>
    <span class="tag">Mosse: <span id="moves">0</span></span>
    <span class="tag">Tempo: <span id="time">00:00</span></span>
    <span id="stars">â˜†â˜†â˜†</span>
  </div>

  <div style="padding:12px;display:grid;gap:12px">
    <div class="card">
      <h2>Obiettivo del livello</h2>
      <div class="small" id="goalText">
        M1â†’M2: fai coincidere <b>NEAR</b> e <b>FAR</b> (stessa altezza Z). Poi porta il punto al centro.
      </div>
      <div class="progress" aria-label="progress"><div id="progress" style="width:0%"></div></div>
    </div>

    <div class="card" id="boardWrap">
      <canvas id="board" width="420" height="420"></canvas>
      <div class="small" style="margin-top:8px">
        Tocca per segnare <b>near</b>, poi <b>far</b> (se richiesto). Trascina per affinare. Il raggio/laser Ã¨ animato: punta al <b>bersaglio</b>.
      </div>
    </div>

    <div class="grid-3">
      <div class="card knob">
        <label>Vite A (CW / CCW)</label>
        <input type="range" min="-2" max="2" step="0.1" value="0" id="kA">
        <div class="small">Î”= <span id="kAVal">0.0</span> micro-giri</div>
      </div>
      <div class="card knob">
        <label>Vite B (CW / CCW)</label>
        <input type="range" min="-2" max="2" step="0.1" value="0" id="kB">
        <div class="small">Î”= <span id="kBVal">0.0</span> micro-giri</div>
      </div>
      <div class="card knob">
        <label>Vite C (CW / CCW)</label>
        <input type="range" min="-2" max="2" step="0.1" value="0" id="kC">
        <div class="small">Î”= <span id="kCVal">0.0</span> micro-giri</div>
      </div>
    </div>

    <div class="grid-2">
      <div class="card">
        <div class="grid-2">
          <button class="btn" id="hint">Hint</button>
          <button class="btn ghost" id="reset">Reset</button>
        </div>
        <div class="small" style="margin-top:8px" id="hintText">Suggerimenti contestuali (senza spoiler troppo forti ðŸ˜‰).</div>
      </div>
      <div class="card">
        <div class="grid-2">
          <button class="btn" id="toggleMode">Training/Real</button>
          <button class="btn ghost" id="nextLevel">Prossimo livello</button>
        </div>
        <div class="small" style="margin-top:8px">
          <span class="badge">Real Mode</span>: usa i tuoi <b>colpi</b> (near/far/nozzle) invece della simulazione. Il gioco valuta e suggerisce.
        </div>
      </div>
    </div>

    <div class="card hidden" id="winCard">
      <h2>Livello completato! ðŸŽ‰</h2>
      <div class="small" id="winMsg">Ottimo allineamento. Pronto al prossimo?</div>
    </div>
  </div>

  <div class="footer">Suggerimento pro: micro-giri ~1/16, stessa altezza Z, lente fuori fino al nozzle.</div>
</div>

<script>
/* ---------- Stato di gioco ---------- */
const STAGES = [
  { key:'m1m2', name:'M1â†’M2', needsFar:true, goal:'Fai coincidere NEAR e FAR (X). Poi centra.' },
  { key:'m2m3', name:'M2â†’M3', needsFar:true, goal:'Fai coincidere NEAR e FAR (Y). Poi centra.' },
  { key:'nozzle', name:'Nozzle', needsFar:false, goal:'Centra il colpo nel foro regolando M3.' },
  { key:'boss', name:'Boss 4 Angoli', needsFar:false, goal:'Tutti e quattro gli angoli devono avere punto centrato.' }
];
let level = 0; // 0..3
let training = true;
let tol = 0.02; // board-normalized
let moves = 0;
let t0 = null, timerId=null;
let scoreStars = 0;

const state = {
  near:null, far:null, target:{x:0.5,y:0.5},
  // base random scenario for training
  scenario:null,
  // screw turns
  turns:{A:0,B:0,C:0},
  // mount vectors (CW) per stage
  mounts:{
    m1m2:[ {n:'Vite A', v:{x:0.00,y:-0.015}},
           {n:'Vite B', v:{x:0.015,y: 0.000}},
           {n:'Vite C', v:{x:-0.015,y:0.000}} ],
    m2m3:[ {n:'Vite A', v:{x:0.00,y:-0.015}},
           {n:'Vite B', v:{x:0.015,y: 0.000}},
           {n:'Vite C', v:{x:-0.015,y:0.000}} ],
    nozzle:[ {n:'Vite A', v:{x:0.00,y:-0.015}},
             {n:'Vite B', v:{x:0.015,y: 0.000}},
             {n:'Vite C', v:{x:-0.015,y:0.000}} ]
  }
};

/* ---------- UI refs ---------- */
const levelTag = document.getElementById('levelTag');
const modeTag  = document.getElementById('modeTag');
const tolVal   = document.getElementById('tolVal');
const movesEl  = document.getElementById('moves');
const timeEl   = document.getElementById('time');
const starsEl  = document.getElementById('stars');
const goalText = document.getElementById('goalText');
const progressEl = document.getElementById('progress');
const winCard = document.getElementById('winCard');
const winMsg = document.getElementById('winMsg');

const kA = document.getElementById('kA');
const kB = document.getElementById('kB');
const kC = document.getElementById('kC');
const kAVal = document.getElementById('kAVal');
const kBVal = document.getElementById('kBVal');
const kCVal = document.getElementById('kCVal');

document.getElementById('playBtn').onclick = startGame;
document.getElementById('reset').onclick = resetLevel;
document.getElementById('hint').onclick = hint;
document.getElementById('nextLevel').onclick = ()=>{ level=(level+1)%STAGES.length; setupLevel(); };
document.getElementById('toggleMode').onclick = ()=>{ training=!training; modeTag.textContent = `ModalitÃ : ${training?'Training':'Real'}`; resetLevel(); };

[kA,kB,kC].forEach(inp=>{
  inp.addEventListener('input', ()=>{
    state.turns[inp.id.slice(-1)] = +inp.value;
    updateKnobLabels(); moves++; movesEl.textContent = moves; drawBoard();
    evaluate();
  });
});

/* ---------- Canvas ---------- */
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d',{alpha:false});
let anim = {t:0, dir:1}; // for laser animation

function drawBoard(){
  const W=canvas.width,H=canvas.height; ctx.clearRect(0,0,W,H);
  // background & board circle
  ctx.fillStyle='#0f1012'; ctx.fillRect(0,0,W,H);
  const r=Math.min(W,H)/2*0.9, cx=W/2, cy=H/2;
  ctx.strokeStyle='#2c2c2e'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
  ctx.setLineDash([4,4]); ctx.beginPath(); ctx.moveTo(cx-r,cy); ctx.lineTo(cx+r,cy); ctx.moveTo(cx,cy-r); ctx.lineTo(cx,cy+r); ctx.stroke(); ctx.setLineDash([]);

  // target
  drawDot(normToPx(state.target), 7, 'rgba(48,209,88,0.25)', true);

  // compute scenario points (training) or use user points (real)
  const s = getScenarioPoints();

  // draw near/far
  if(s.near) drawDot(normToPx(s.near), 8, '#0a84ff');
  if(STAGES[level].needsFar && s.far) drawDot(normToPx(s.far), 8, '#ff9f0a');

  // laser line animation
  if(s.near && (s.far || level===2)){
    ctx.lineWidth=2;
    const a = anim.t;
    const from = STAGES[level].needsFar ? normToPx(s.near) : normToPx(s.near);
    const to   = STAGES[level].needsFar ? normToPx(s.far)  : normToPx(state.target);
    const gx = from.x + (to.x-from.x)*a;
    const gy = from.y + (to.y-from.y)*a;
    const grad = ctx.createLinearGradient(from.x,from.y,to.x,to.y);
    grad.addColorStop(0,'#0fb7ff'); grad.addColorStop(1,'#34c759');
    ctx.strokeStyle = grad;
    ctx.beginPath(); ctx.moveTo(from.x,from.y); ctx.lineTo(gx,gy); ctx.stroke();
  }
}

function drawDot(p, rad, fill, ring=false){
  ctx.fillStyle=fill; ctx.beginPath(); ctx.arc(p.x,p.y,rad,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#fff'; ctx.lineWidth=2; if(!ring) ctx.stroke();
}

function normToPx(p){ const r=Math.min(canvas.width,canvas.height)/2*0.9; const cx=canvas.width/2, cy=canvas.height/2;
  return {x: cx + (p.x-0.5)*2*r, y: cy + (p.y-0.5)*2*r}; }
function pxToNorm(p){ const r=Math.min(canvas.width,canvas.height)/2*0.9; const cx=canvas.width/2, cy=canvas.height/2;
  return {x: clamp(((p.x-cx)/(2*r))+0.5,0.02,0.98), y: clamp(((p.y-cy)/(2*r))+0.5,0.02,0.98)}; }
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

/* ---------- Interazioni touch: tap/drag per punti real ---------- */
let dragging=null;
canvas.addEventListener('pointerdown',e=>{
  if(training){ shake(boardWrap); return; } // in training non si toccano i punti
  const p = pxToNorm({x:e.offsetX, y:e.offsetY});
  if(!state.near){ state.near=p; }
  else if(STAGES[level].needsFar && !state.far){ state.far=p; }
  else { state.near=p; if(!STAGES[level].needsFar) state.far=null; }
  drawBoard(); evaluate();
});
canvas.addEventListener('pointermove',e=>{
  if(!dragging || training) return;
});
canvas.addEventListener('pointerup',()=>dragging=null);

/* ---------- Logica scenario ---------- */
function randomScenario(){
  // Create a base near point around center +/-0.08, and a separation vector 0.04..0.12
  const near = {x:0.5 + rnd(-0.08,0.08), y:0.5 + rnd(-0.08,0.08)};
  let sepMag = rnd(0.04,0.12);
  let ang = (level===0) ? rnd(-0.3,0.3) : (level===1) ? (Math.PI/2 + rnd(-0.3,0.3)) : 0;
  const sep = {x: Math.cos(ang)*sepMag, y: Math.sin(ang)*sepMag};
  const centerOff = {x:rnd(-0.06,0.06), y:rnd(-0.06,0.06)};
  return {near, sep, centerOff}; // far = near + sep (poi corretto dalle viti)
}

function getScenarioPoints(){
  if(training){
    const m = getMount();
    const t = state.turns;
    const wA = m[0].v, wB = m[1].v, wC = m[2].v;
    // training base
    const base = state.scenario || (state.scenario = randomScenario());
    let near = base.near;
    let far  = STAGES[level].needsFar ? {x: near.x + base.sep.x, y: near.y + base.sep.y} : null;

    // effect of screws:
    // - for M1/M2 levels: screws primarily affect separation (bring far toward near)
    // - for nozzle: screws move the single point toward center
    const eff = (turn, vec)=>({x: turn*vec.x*1.8, y: turn*vec.y*1.8});
    if(level===0 || level===1){
      const d = sumVec([ eff(t.A,wA), eff(t.B,wB), eff(t.C,wC) ]);
      far = {x: far.x - d.x, y: far.y - d.y}; // invert to "chiudere" near/far
      // small center walk
      near = {x: near.x + d.x*0.15 + base.centerOff.x*0.0, y: near.y + d.y*0.15 + base.centerOff.y*0.0};
    } else if(level===2){
      const d = sumVec([ eff(t.A,wA), eff(t.B,wB), eff(t.C,wC) ]);
      near = {x: near.x + d.x, y: near.y + d.y};
    } else if(level===3){
      // Boss: four corners synthesized; we visualize just the center behavior
      const d = sumVec([ eff(t.A,wA), eff(t.B,wB), eff(t.C,wC) ]);
      near = {x: 0.5 + d.x*0.8, y: 0.5 + d.y*0.8};
    }
    return {near: clampPt(near), far: far?clampPt(far):null};
  } else {
    return {near: state.near, far: state.far};
  }
}
function sumVec(arr){ return arr.reduce((a,b)=>({x:a.x+b.x,y:a.y+b.y}),{x:0,y:0}); }
function clampPt(p){ return {x:clamp(p.x,0.02,0.98), y:clamp(p.y,0.02,0.98)}; }
function rnd(a,b){ return a + Math.random()*(b-a); }
function getMount(){
  if(level===0) return state.mounts.m1m2;
  if(level===1) return state.mounts.m2m3;
  return state.mounts.nozzle;
}

/* ---------- Valutazione & punteggio ---------- */
function evaluate(){
  const s = getScenarioPoints();
  let progress = 0;
  let ok = false;
  if(level===0 || level===1){
    if(!s.near || !s.far){ setStars(0); setProgress(5); return; }
    const sep = Math.hypot(s.far.x-s.near.x, s.far.y-s.near.y);
    const center = {x:(s.near.x+s.far.x)/2, y:(s.near.y+s.far.y)/2};
    const centErr = Math.hypot(center.x-0.5, center.y-0.5);
    progress = Math.max(0, 100 - (sep*220 + centErr*140*2));
    ok = (sep <= tol && centErr <= tol*1.2);
  } else if(level===2){
    if(!s.near){ setStars(0); setProgress(5); return; }
    const err = Math.hypot(s.near.x-0.5, s.near.y-0.5);
    progress = Math.max(0, 100 - err*240);
    ok = (err <= tol);
  } else {
    const err = Math.hypot(s.near.x-0.5, s.near.y-0.5);
    progress = Math.max(0, 100 - err*240);
    ok = (err <= tol*1.1);
  }
  setProgress(progress);

  if(ok){
    const stars = (moves<=6) ? 3 : (moves<=10 ? 2 : 1);
    setStars(stars);
    winCard.classList.remove('hidden');
    winCard.classList.add('win');
    winMsg.innerHTML = (level<2)
      ? "Near/Far sovrapposti e centrati. ðŸ”§"
      : (level===2 ? "Nozzle centrato. Rimetti la lente (convesso in basso)." : "Boss domato! Gantry ok.");
    stopTimer();
  } else {
    setStars(0);
    winCard.classList.add('hidden');
    startTimer();
  }
}

/* ---------- Hint intelligente ---------- */
function hint(){
  const s = getScenarioPoints();
  if(level===2 && s.near){
    const e = {x:0.5 - s.near.x, y:0.5 - s.near.y};
    const mount = getMount();
    const choice = rankScrews(e, mount);
    document.getElementById('hintText').textContent =
      `Nozzle: usa ${choice[0].s.n} (+${fmtTurns(choice[0].gain)} CW) e poi ${choice[1].s.n} (+${fmtTurns(choice[1].gain/2)}).`;
    pulse(hint);
    return;
  }
  if((level===0 || level===1) && s.near && s.far){
    const sep = {x:s.far.x - s.near.x, y:s.far.y - s.near.y};
    const mount = getMount();
    const choice = rankScrews({x:-sep.x, y:-sep.y}, mount);
    document.getElementById('hintText').textContent =
      `${STAGES[level].name}: avvicina near/far con ${choice[0].s.n} (+${fmtTurns(choice[0].gain)}), poi ${choice[1].s.n} (+${fmtTurns(choice[1].gain/2)}).`;
    pulse(hint);
    return;
  }
  document.getElementById('hintText').textContent = "Segna i punti prima (near/far o nozzle).";
  shake(boardWrap);
}
function rankScrews(error, mount){
  const len = (v)=>Math.hypot(v.x,v.y)||1e-6;
  const nrm = (v)=>({x:v.x/len(v), y:v.y/len(v)});
  const en = nrm(error);
  const arr = mount.map(s=>({s,score: en.x*(s.v.x/len(s.v)) + en.y*(s.v.y/len(s.v))}));
  arr.sort((a,b)=>b.score-a.score);
  // gain ~ magnitude suggestion
  return arr.map((x,i)=>({s:x.s, gain: (i===0?1.0:0.6) * clamp(len(error)/0.05,0.5,3.0)}));
}
function fmtTurns(x){ return (Math.round(x*10)/10).toFixed(1); }

/* ---------- Timer & stars & progress ---------- */
function startTimer(){ if(timerId) return; t0 = performance.now(); timerId = setInterval(()=>{
  const t = Math.floor((performance.now()-t0)/1000);
  timeEl.textContent = `${String(Math.floor(t/60)).padStart(2,'0')}:${String(t%60).padStart(2,'0')}`;
}, 250);}
function stopTimer(){ clearInterval(timerId); timerId=null; }
function setStars(n){ scoreStars=n; starsEl.textContent = (n>=1?'â˜…':'â˜†') + (n>=2?'â˜…':'â˜†') + (n>=3?'â˜…':'â˜†'); }
function setProgress(pct){ progressEl.style.width = `${clamp(pct,0,100)}%`; }

/* ---------- Helpers UI ---------- */
function pulse(el){ el.classList.add('win'); setTimeout(()=>el.classList.remove('win'),400); }
function shake(el){ el.classList.add('shake'); setTimeout(()=>el.classList.remove('shake'),300); }
function updateKnobLabels(){ kAVal.textContent=state.turns.A.toFixed(1); kBVal.textContent=state.turns.B.toFixed(1); kCVal.textContent=state.turns.C.toFixed(1); }

/* ---------- Avvio / Reset / Setup ---------- */
function startGame(){
  level = 0; training = true; setupLevel();
}
function setupLevel(){
  // UI text
  const st = STAGES[level];
  levelTag.textContent = `Livello ${level+1} Â· ${st.name}`;
  goalText.textContent = st.goal;
  // reset state
  state.near = null; state.far = null; state.turns = {A:0,B:0,C:0};
  [kA,kB,kC].forEach(inp=>{inp.value=0;});
  updateKnobLabels();
  moves = 0; movesEl.textContent = moves; setStars(0); setProgress(0);
  winCard.classList.add('hidden');
  state.scenario = randomScenario();
  tol = (level===2?0.02:0.02); tolVal.textContent = tol.toFixed(3);
  drawBoard(); evaluate(); startTimer();
}
function resetLevel(){
  state.near = null; state.far = null; state.turns = {A:0,B:0,C:0};
  [kA,kB,kC].forEach(inp=>{inp.value=0;});
  updateKnobLabels(); moves=0; movesEl.textContent=moves;
  winCard.classList.add('hidden');
  state.scenario = training ? randomScenario() : null;
  drawBoard(); evaluate();
}

/* ---------- Animazione laser ---------- */
function tick(){
  anim.t += 0.02 * anim.dir;
  if(anim.t>=1 || anim.t<=0) anim.dir*=-1;
  drawBoard();
  requestAnimationFrame(tick);
}
tick();
setupLevel();
</script>
</body>
</html>
